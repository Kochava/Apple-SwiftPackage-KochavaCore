#if 0
#elif defined(__arm64__) && __arm64__
// Generated by Apple Swift version 5.7.1 (swiftlang-5.7.1.135.3 clang-1400.0.29.51)
#ifndef KOCHAVACORE_SWIFT_H
#define KOCHAVACORE_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wduplicate-method-match"
#pragma clang diagnostic ignored "-Wauto-import"
#if defined(__OBJC__)
#include <Foundation/Foundation.h>
#endif
#if defined(__cplusplus)
#include <cstdint>
#include <cstddef>
#include <cstdbool>
#else
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#endif

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if defined(__OBJC__)
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#endif
#if !defined(SWIFT_EXTERN)
# if defined(__cplusplus)
#  define SWIFT_EXTERN extern "C"
# else
#  define SWIFT_EXTERN extern
# endif
#endif
#if !defined(SWIFT_CALL)
# define SWIFT_CALL __attribute__((swiftcall))
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT noexcept
#endif
#else
#if !defined(SWIFT_NOEXCEPT)
# define SWIFT_NOEXCEPT 
#endif
#endif
#if defined(__cplusplus)
#if !defined(SWIFT_CXX_INT_DEFINED)
#define SWIFT_CXX_INT_DEFINED
namespace swift {
using Int = ptrdiff_t;
using UInt = size_t;
}
#endif
#endif
#if defined(__OBJC__)
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import UIKit;
#endif

#endif
#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="KochavaCore",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

#if defined(__OBJC__)

@class KVANetworking;

SWIFT_PROTOCOL("_TtP11KochavaCore27KVANetworkingSetterProvider_")
@protocol KVANetworkingSetterProvider
@property (nonatomic, strong) KVANetworking * _Nullable networking;
@end

@class NSString;

/// A class which collects and/or adapts a value to a variety of contexts.
SWIFT_CLASS_NAMED("KVAAdapter")
@interface KVAAdapter : NSObject <KVANetworkingSetterProvider>
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// An instance of networking.
/// This exists here is related to the both conformances to KVAExecutable and KVANetworkingSetterProvider.  When this instance is constructed it generally receives a value here.  However, when this instance is constructed and then executed as an executable from within the the networking class, the networking class will also when possible stamp itself here as an indication of where it originated, so that this instance can properly utilizely networking resources.
@property (nonatomic, weak) KVANetworking * _Nullable networking;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class for working with the App Groups capability.
SWIFT_CLASS_NAMED("KVAAppGroups")
@interface KVAAppGroups : NSObject
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAAppGroups * _Nonnull shared;)
+ (KVAAppGroups * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// A shared instance, for convenience— optional.
/// See var <code>shared</code>.  This variable will be nil prior to the shared instance being defaulted.  This may be used to optionally invalidate any existing shared instance without causing it to first be defaulted in the process.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAAppGroups * _Nullable shared_optional;)
+ (KVAAppGroups * _Nullable)shared_optional SWIFT_WARN_UNUSED_RESULT;
/// A string which corresponds to an app group identifier to be used as a shared container for the Kochava SDK.
@property (nonatomic, copy) NSString * _Nullable deviceAppGroupIdentifier;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class to manage the beginning and ending of a background task.
/// This class assists in keeping the host app alive, to give KVANetTransaction(s) and a chance to be sent, and other critical tasks the opportunity to finish, in the situation where the app is resigning active.
SWIFT_CLASS_NAMED("KVABackgroundTaskController")
@interface KVABackgroundTaskController : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class which defines an keyed collection of objects.
/// <h2>Features</h2>
/// <ul>
///   <li>
///     <em>Identification</em> — An identifier provides a unique identifier for use within a collection.  This enables objects to be referenced from JSON objects.  It is also a base component for the formation of a key which can be used to store the associated information in persistent storage.
///   </li>
///   <li>
///     <em>Thread Safety</em> — Objects can be registered, re-registered, or removed in a thread-safe manner.
///   </li>
/// </ul>
SWIFT_CLASS_NAMED("KVACollection")
@interface KVACollection : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class KVAContext;
@class NSNumber;
@class NSDate;

/// A feature which serves as an authority related to consent for the sharing of personal data.
/// Data sharing privacy laws such as GDPR require consent to be obtained before certain kinds of personal data may be shared with partners.
SWIFT_CLASS_NAMED("KVAConsent")
@interface KVAConsent : NSObject <NSCopying>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (id _Nullable)kva_asForContext:(KVAContext * _Nullable)context SWIFT_WARN_UNUSED_RESULT;
/// Return a boolean indicating if the app may collect (or calculate) data which may be subject to consent.
/// Return true if consent is not required or else is granted.  This will immediately return false if the consent requirement(s) have been updated but not an updated consent response has not yet been given from the user.  Compare with mayKeepBool, mayPersistBool, and mayShareBool.
- (BOOL)mayCollectBool SWIFT_WARN_UNUSED_RESULT;
/// Return a boolean indicating if the app may persist (or retain in persistent storage) data which may be subject to consent.
/// Return true if consent is not required or else is granted.  This will immediately return false if the consent requirement(s) have been updated but not an updated consent response has not yet been given from the user.  Compare with mayCollectBool, mayKeepBool, and mayShareBool.
- (BOOL)mayPersistBool SWIFT_WARN_UNUSED_RESULT;
/// Return a boolean indicating if the app may share (or export) data which may be subject to consent.
/// Return true if consent is not required or else is granted.  This will immediately return false if the consent requirement(s) have been updated but not an updated consent response has not yet been given from the user.  Compare with mayCollectBool, mayKeepBool, and mayPersistBool.
- (BOOL)mayShareBool SWIFT_WARN_UNUSED_RESULT;
/// Return a boolean indicating if the app may keep (or retain in memory) data which may be subject to consent.
/// Return true if consent is not required or else the user did not otherwise previously deny consent.  This will return true while consent is not known, as long as the previous response did not deny consent.  This includes when the definition for consent has changed and the user previously granted consent.  Compare with mayCollectBool, mayPersistBool, and mayShareBool.
- (BOOL)mayKeepBool SWIFT_WARN_UNUSED_RESULT;
/// A boolean indicating if GDPR applies to this user.
@property (nonatomic, readonly) BOOL gdprAppliesBool;
/// A boolean indicating if GDPR is enabled.
@property (nonatomic, readonly) BOOL gdprEnabledBool;
/// A boolean wrapped in an NSNumber which indicates if consent has been granted.
/// A value of true indicates consent was granted.  A value of false indicates consent was denied.  A value of nil exists when the user has not provided a response.
/// This API is provided for Objective-C support.  In Swift use var <code>grantedBool</code>.
@property (nonatomic, strong) NSNumber * _Nullable grantedBoolNumber;
/// Return a date for when consent was granted.
/// If grantedBool == true, then this returns responseDate.  If not, then this returns nil.
@property (nonatomic, readonly, copy) NSDate * _Nullable grantedDate;
/// A boolean indicating if consent is required.
/// This is expected to be true when the user is taken to be under the scope of consent gathering requirements such as GDPR.  This is expected to be the case for EU citizens within EU territory or abroad, and non-EU citizens within EU territory.  When requiredBool is undefined this will return a default of true.  It will also be overridden to false when intelligentManagementBool is false.  This variable may also be set when Manual Managed Requirements is turned on.  See also gdprAppliesBool.
@property (nonatomic, readonly) BOOL requiredBool;
/// A date representing the last time the user did respond concerning consent.
/// This includes both positive and negative responses.  This value is nil when the user has not provided a response.
@property (nonatomic, readonly, copy) NSDate * _Nullable responseDate;
@end


/// A class which defines a context.
/// This class provides the means of defining the context for something that is being done.  It is generally used to identify a target or provider.
SWIFT_CLASS_NAMED("KVAContext")
@interface KVAContext : NSObject
/// A context which represents the host app.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAContext * _Nonnull host;)
+ (KVAContext * _Nonnull)host SWIFT_WARN_UNUSED_RESULT;
/// A context which represents the log.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAContext * _Nonnull log;)
+ (KVAContext * _Nonnull)log SWIFT_WARN_UNUSED_RESULT;
/// A context which represents persistentStorage.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAContext * _Nonnull persistentStorage;)
+ (KVAContext * _Nonnull)persistentStorage SWIFT_WARN_UNUSED_RESULT;
/// A context which represents the SDK.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAContext * _Nonnull sdk;)
+ (KVAContext * _Nonnull)sdk SWIFT_WARN_UNUSED_RESULT;
/// A context which represents the Server.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAContext * _Nonnull server;)
+ (KVAContext * _Nonnull)server SWIFT_WARN_UNUSED_RESULT;
/// A context which represents the Server, and is un-restricted by considerations such as allowed and denied identifiers.
/// This is of particular relevance with KVANetTransaction(s) where allowed and/or denied identifiers may not (or not yet) be known, such as config retrievals.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAContext * _Nonnull serverUnrestricted;)
+ (KVAContext * _Nonnull)serverUnrestricted SWIFT_WARN_UNUSED_RESULT;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class which defines a product.
/// A product in this context generally refers to the result of a build.  A product can be used to represent a framework, application, or application extension.
SWIFT_CLASS_NAMED("KVAProduct")
@interface KVAProduct : NSObject
/// Create an instance of class <code>KVAProduct</code>.
/// <h2>Example</h2>
/// \code
/// let product = KVAProduct(
///     apiVersionString: "1",
///     buildDateString: nil,
///     bundleIdentifier: Bundle(for: Self.self).bundleIdentifier,
///     bundleType: "xcframework",
///     compilerFlagNameArray: nil,
///     moduleName: "MyModule",
///     name: "MyOrganization MyModule",
///     organizationName: "My Organization",
///     reverseDomainName: "com.myCompany.MyProduct",
///     valueSourceCollection: nil,
///     versionString: "1.0.0"
/// )
///
/// \endcode\param apiVersionString An optional API version string.  This property is used to establish API compatibility between products.  API compatibility is assumed to be assured when the value compares to be equal for all products with the same organizationName.
///
/// \param buildDateString An optional string containing the date when the product was built.  It is recommended that you source this a compile time.  The format is optional, but it is recommended that you provide the date in an ISO 8601 date string.
///
/// \param bundleIdentifier A string containing the bundle identifier associated with this product.  This property may be used to cross-reference this product from a Class.  Logging uses this to take the class for a LogMessage and lookup the associated Product.
///
/// \param bundleType The bundle type.  Examples:  “app”, “xcframework”, “static library”.
///
/// \param compilerFlagNameArray An array containing strings which are the names of compiler flags.
///
/// \param moduleName The name of the module.  Example:  “KochavaCore”.
///
/// \param name The name.  Example: “Apple.Core”.
///
/// \param organizationName The name of the organization representing the product.  Example:  “Kochava”.
///
/// \param reverseDomainName The reverse domain name style representation of the name of the product.  This is used in the definition of keys for persistent storage, dispatch queues, etc.  Example:  “com.kochava.KochavaCore”.
///
/// \param valueSourceCollection A collection containing value sources for variable substitution with an NSPredicate, used for predicate evaluation and token substitution.
///
/// \param versionString A version string.
///
- (nonnull instancetype)initWithAPIVersionString:(NSString * _Nullable)apiVersionString buildDateString:(NSString * _Nullable)buildDateString bundleIdentifier:(NSString * _Nullable)bundleIdentifier bundleType:(NSString * _Nonnull)bundleType compilerFlagNameArray:(NSArray<NSString *> * _Nullable)compilerFlagNameArray moduleName:(NSString * _Nonnull)moduleName name:(NSString * _Nonnull)name organizationName:(NSString * _Nonnull)organizationName reverseDomainName:(NSString * _Nullable)reverseDomainName valueSourceCollection:(KVACollection * _Nullable)valueSourceCollection versionString:(NSString * _Nullable)versionString dependentProductClassNameStringArray:(NSArray<NSString *> * _Nullable)dependentProductClassNameStringArray closure_resetClasses:(NSDictionary * _Nullable (^ _Nullable)(BOOL, BOOL))closure_resetClasses closure_resetVariables:(NSDictionary * _Nullable (^ _Nullable)(BOOL, BOOL))closure_resetVariables closure_didRegister:(void (^ _Nullable)(KVAProduct * _Nonnull))closure_didRegister OBJC_DESIGNATED_INITIALIZER;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Resets the product.
/// This involves resetting variables to their original states.  This may include releasing shared instances.  When parameter deleteLocalDataBool is passed true it also includes erasing any keys from persistent storage which are associated with the product.  This method will complete asynchronously.  Before working with this product again you should wait until the reset has completed.  See method reset(deleteLocalDataBool:closure_didComplete:).
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
- (void)resetWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool;
/// Resets the product.
/// This involves resetting variables to their original states.  This may include releasing shared instances.  When parameter deleteLocalDataBool is passed true it also includes erasing any keys from persistent storage which are associated with the product.  This method will complete asynchronously.  Before working with this product again you should wait until the reset has completed.
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
/// \param closure_didComplete A closure which is called upon completion.
///
- (void)resetWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool closure_didComplete:(void (^ _Nullable)(void))closure_didComplete;
/// Resets the product.
/// This involves resetting variables to their original states.  This may include releasing shared instances.  When parameter deleteLocalDataBool is passed true it also includes erasing any keys from persistent storage which are associated with the product.  When parameter includeExternalVariablesBool is passed true it includes additional variables which are bearing on the functionality of the product but otherwise external to it.  This refers to third party variables.
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
/// \param includeExternalBool A boolean indicating whether or not external variables should be deleted.  This is intended for testing purposes.  See func <code>reset(deleteLocalDataBool:)</code> which always supplies this parameter as false.
///
/// \param includeDeviceAppGroupBool A boolean indicating whether or not the deviceAppGroup user defaults should be deleted.  This is where App Clip data is stored.
///
/// \param logMessagePrintBool A boolean indicating if a log messages consistent with this being a call to a public entry point should be printed.
///
/// \param closure_didComplete A closure which is called upon completion.
///
- (void)resetWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool includeExternalBool:(BOOL)includeExternalBool includeDeviceAppGroupBool:(BOOL)includeDeviceAppGroupBool logMessagePrintBool:(BOOL)logMessagePrintBool closure_didComplete:(void (^ _Nullable)(void))closure_didComplete;
/// Shut down the product.
/// This can be regarded as being equivalent to performing a reset, but may also include hints to avoid performing automatic behavior consistent with being freshly initialized.   This method will complete asynchronously.  Before working with this product again you should wait until the shutdown has completed.  See method shutdown(deleteLocalDataBool:closure_didComplete:).
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
- (void)shutdownWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool;
/// Shut down the product.
/// This can be regarded as being equivalent to performing a reset, but may also include hints to avoid performing automatic behavior consistent with being freshly initialized.  This method will complete asynchronously.  Before working with this product again you should wait until the shutdown has completed.
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
/// \param closure_didComplete A closure which is called upon completion.
///
- (void)shutdownWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool closure_didComplete:(void (^ _Nullable)(void))closure_didComplete;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class which defines the core product.
/// A product in this context generally refers to the result of a build.
SWIFT_CLASS_NAMED("KVACoreProduct")
@interface KVACoreProduct : KVAProduct
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAProduct * _Nonnull shared;)
+ (KVAProduct * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)initWithAPIVersionString:(NSString * _Nullable)apiVersionString buildDateString:(NSString * _Nullable)buildDateString bundleIdentifier:(NSString * _Nullable)bundleIdentifier bundleType:(NSString * _Nonnull)bundleType compilerFlagNameArray:(NSArray<NSString *> * _Nullable)compilerFlagNameArray moduleName:(NSString * _Nonnull)moduleName name:(NSString * _Nonnull)name organizationName:(NSString * _Nonnull)organizationName reverseDomainName:(NSString * _Nullable)reverseDomainName valueSourceCollection:(KVACollection * _Nullable)valueSourceCollection versionString:(NSString * _Nullable)versionString dependentProductClassNameStringArray:(NSArray<NSString *> * _Nullable)dependentProductClassNameStringArray closure_resetClasses:(NSDictionary * _Nullable (^ _Nullable)(BOOL, BOOL))closure_resetClasses closure_resetVariables:(NSDictionary * _Nullable (^ _Nullable)(BOOL, BOOL))closure_resetVariables closure_didRegister:(void (^ _Nullable)(KVAProduct * _Nonnull))closure_didRegister OBJC_DESIGNATED_INITIALIZER;
@end


/// Defines the parameters for the core product.
SWIFT_CLASS("_TtC11KochavaCore20KVACoreProductParams")
@interface KVACoreProductParams : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class for providing diagnostic messages in a format which has been standardized across all Kochava SDK platforms.
SWIFT_CLASS_NAMED("KVADiagnostic")
@interface KVADiagnostic : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class which defines an entry in a dictionary.
/// This class provides the means of defining how an element in a dictionary should be formatted.
SWIFT_CLASS_NAMED("KVADictionaryEntryFormat")
@interface KVADictionaryEntryFormat : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class which defines the structure of a dictionary.
/// This class provides the means of defining how a dictionary should be formatted.
SWIFT_CLASS_NAMED("KVADictionaryFormat")
@interface KVADictionaryFormat : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVATask;

/// A class providing standardized access to dispatch queues.
/// This class provides methods to work with dispatch queues with standardized features.  All such dispatches are identified with a sourceIdentifier, which can be used in reporting issues.
SWIFT_CLASS_NAMED("KVADispatchQueue")
@interface KVADispatchQueue : NSObject
/// A global concurrent utility-qos DispatchQueue, which can be used generically to ensure that code can wait and not block execution.
/// Any sub-system which wishes to ensure execution can wait and not block execution in a global sense may use this queue.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVADispatchQueue * _Nonnull globalConcurrent;)
+ (KVADispatchQueue * _Nonnull)globalConcurrent SWIFT_WARN_UNUSED_RESULT;
/// A global serial utility-qos DispatchQueue, which can be used generically to ensure that code execution is synchronized.
/// Any sub-system which wishes to synchronize code execution in a global sense may use this queue.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVADispatchQueue * _Nonnull globalSerial;)
+ (KVADispatchQueue * _Nonnull)globalSerial SWIFT_WARN_UNUSED_RESULT;
/// The main dispatch queue.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVADispatchQueue * _Nonnull main;)
+ (KVADispatchQueue * _Nonnull)main SWIFT_WARN_UNUSED_RESULT;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Asynchronously dispatch and execute the provided closure providing standardized handling for the requirements of a public entry point.
/// This always uses the default dispatch queue (globalSerial dispatch queue).
/// \param sourceIdentifier A unique identifier for the location in code from which this originated.  It may be a universally unique identifier (UUID) or a friendly name such as “func someFunc()”.  It is generally preferrable to use a friendly name for public methods, whereas a UUID may be more appropriate for internal methods.
///
/// \param sourceClass The class which is the source for the call.
///
/// \param closure The closure to execute (conditionally).
///
+ (void)asyncForPublicEntryPointWithSourceIdentifier:(NSString * _Nullable)sourceIdentifier hostAPICallDiagnosticHeadlineString:(NSString * _Nullable)hostAPICallDiagnosticHeadlineString sourceClass:(Class _Nullable)sourceClass closure:(void (^ _Nullable)(void))closure;
/// Asynchronously dispatch and execute the provided closure.
/// \param sourceIdentifier A unique identifier for the location in code from which this originated.  It may be a universally unique identifier (UUID) or a friendly name such as “func someFunc()”.  It is generally preferrable to use a friendly name for public methods, whereas a UUID may be more appropriate for internal methods.
///
/// \param closure The closure to execute (conditionally).
///
- (void)asyncWithSourceIdentifier:(NSString * _Nullable)sourceIdentifier closure:(void (^ _Nullable)(void))closure;
/// Asynchronously dispatch and execute the provided closure.
/// \param sourceIdentifier A unique identifier for the location in code from which this originated.  It may be a universally unique identifier (UUID) or a friendly name such as “func someFunc()”.  It is generally preferrable to use a friendly name for public methods, whereas a UUID may be more appropriate for internal methods.
///
/// \param sourceClass The class which is the source for the call.
///
/// \param closure The closure to execute (conditionally).
///
- (void)asyncWithSourceIdentifier:(NSString * _Nullable)sourceIdentifier sourceClass:(Class _Nullable)sourceClass closure:(void (^ _Nullable)(void))closure;
/// Asynchronously dispatch after a given timeInterval and execute the provided closure.
/// \param sourceIdentifier A unique identifier for the location in code from which this originated.  It may be a universally unique identifier (UUID) or a friendly name such as “func someFunc()”.  It is generally preferrable to use a friendly name for public methods, whereas a UUID may be more appropriate for internal methods.
///
/// \param timeInterval The TimeInterval to async after.
///
/// \param closure The closure to execute (conditionally).
///
- (void)asyncAfterWithSourceIdentifier:(NSString * _Nullable)sourceIdentifier timeInterval:(NSTimeInterval)timeInterval closure:(void (^ _Nullable)(void))closure;
/// Asynchronously dispatch after a given timeInterval with other dependencies and execute the provided closure.
/// \param networking An instance of networking.  From this can be derived prerequisite tasks from their associated names, sleep support, privacy, intelligent consent, etc.
///
/// \param sourceIdentifier A unique identifier for the location in code from which this originated.  It may be a universally unique identifier (UUID) or a friendly name such as “func someFunc()”.  It is generally preferrable to use a friendly name for public methods, whereas a UUID may be more appropriate for internal methods.
///
/// \param prerequisiteTaskIdentifierArray An array of task identifiers which are regarded to be prerequisites which must be fulfilled before this task may start.  The preferred order is to place the task identifiers in the reverse order that they are expected to typically execute, with the last task at the front of the list.
///
/// \param prerequisiteTaskArray An array of task objects which are regarded to be prerequisites which must be fulfilled before this task may start.
///
/// \param timeInterval The TimeInterval to async after.
///
/// \param timeIntervalStartsAfterPrerequisiteTasksBool A boolean which when true causes the timeInterval to not start until all prerequisites have been completed.
///
/// \param closure The closure to execute (conditionally).
///
- (void)asyncAfterWithNetworking:(KVANetworking * _Nullable)networking sourceIdentifier:(NSString * _Nullable)sourceIdentifier prerequisiteTaskIdentifierArray:(NSArray<NSString *> * _Nullable)prerequisiteTaskIdentifierArray prerequisiteTaskArray:(NSArray<KVATask *> * _Nullable)prerequisiteTaskArray timeInterval:(NSTimeInterval)timeInterval timeIntervalStartsAfterPrerequisiteTasksBool:(BOOL)timeIntervalStartsAfterPrerequisiteTasksBool closure:(void (^ _Nullable)(void))closure;
/// Asynchronously dispatch after a stepped-settling dispatch.
/// The purpose of this dispatch recognizes that when we receive some form of wrapping trigger that really what we’re looking for is the moment in which that trigger’s entire body of work has completed.  Our goal is to move forward after the work associated with punctuated moments has settled.  The use of a stepped-settling dispatch provides a general form of assurance which minimizes the need for other forms of waits downstream.
/// When used to confirm that the shutdown of the sdk had completed for testing, in-between tests, using 5 steps it seemed to be sufficient.  It was taken up to 12 steps to help to ensure that it is also future proof for that use case.  If ever the number of steps were insufficient it could lead to the need to compensate in other ways later downstream.  The number of steps could be increased if ever it was found to be insufficient, but it’s unlikely that should ever occur.  If you find yourself here wondering if more steps are needed, there’s probably something else going on that you’re looking to compensate for.  You may either need comprehensive async and await, or else a concrete time-based delay.
- (void)asyncAfterSteppedSettlingDispatchWithSourceIdentifier:(NSString * _Nullable)sourceIdentifier closure:(void (^ _Nullable)(void))closure;
/// Asynchronously dispatch and execute the provided closure providing standardized handling for the requirements of a public entry point.
/// This always uses the default dispatch queue (globalSerial dispatch queue).
/// \param sourceIdentifier A unique identifier for the location in code from which this originated.  It may be a universally unique identifier (UUID) or a friendly name such as “func someFunc()”.  It is generally preferrable to use a friendly name for public methods, whereas a UUID may be more appropriate for internal methods.
///
/// \param sourceClass The class which is the source for the call.
///
/// \param logMessagePrintBool A boolean indicating if a log messages consistent with this being a call to a public entry point should be printed.
///
/// \param asyncBool A boolean indicating if this closure should be executed asynchronously.
///
/// \param closure The closure to execute (conditionally).
///
+ (void)executeForPublicEntryPointWithSourceIdentifier:(NSString * _Nullable)sourceIdentifier hostAPICallDiagnosticHeadlineString:(NSString * _Nullable)hostAPICallDiagnosticHeadlineString sourceClass:(Class _Nullable)sourceClass logMessagePrintBool:(BOOL)logMessagePrintBool asyncBool:(BOOL)asyncBool closure:(void (^ _Nullable)(void))closure;
/// Asynchronously dispatch and execute the provided closure providing standardized handling for the requirements of a public entry point.
/// This always uses the default dispatch queue (globalSerial dispatch queue).
/// \param dispatchQueue A dispatchQueue to use.  Will default to globalSerial if not provided.
///
/// \param sourceIdentifier A unique identifier for the location in code from which this originated.  It may be a universally unique identifier (UUID) or a friendly name such as “func someFunc()”.  It is generally preferrable to use a friendly name for public methods, whereas a UUID may be more appropriate for internal methods.
///
/// \param sourceClass The class which is the source for the call.
///
/// \param logMessagePrintBool A boolean indicating if a log messages consistent with this being a call to a public entry point should be printed.
///
/// \param asyncBool A boolean indicating if this closure should be executed asynchronously.
///
/// \param closure The closure to execute (conditionally).
///
+ (void)executeWithDispatchQueue:(KVADispatchQueue * _Nullable)dispatchQueue sourceIdentifier:(NSString * _Nullable)sourceIdentifier hostAPICallDiagnosticHeadlineString:(NSString * _Nullable)hostAPICallDiagnosticHeadlineString sourceClass:(Class _Nullable)sourceClass logMessagePrintBool:(BOOL)logMessagePrintBool asyncBool:(BOOL)asyncBool closure:(void (^ _Nullable)(void))closure;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS_NAMED("KVAFile")
@interface KVAFile : NSObject
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class KVALogLevel;
@class KVALogMessage;

/// A class which constitutes a log, which is a collection of log messages.
SWIFT_CLASS_NAMED("KVALog")
@interface KVALog : NSObject
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALog * _Nonnull shared;)
+ (KVALog * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
/// The visible maximum log level for log messages.
@property (nonatomic, strong) KVALogLevel * _Nullable level;
/// A boolean indicating if log messages may be printed using os_log.
/// Default true.  When disabled, log messages will fall back to NSLog or Swift’s print.  NSLog and Swift’s print lack certain features which os_log has, but they may print in environments where os_log is not supported.
@property (nonatomic) BOOL osLogEnabledBool;
/// A boolean indicating if log messages should be pretty printed.
/// Default true.
@property (nonatomic) BOOL prettyPrintBool;
/// A boolean indicating if log messages should be separated by new line and then printed individually.
/// Default false.  This can be used to overcome truncation issues, but it will add message prefixes to the beginning of each line.
@property (nonatomic) BOOL printLinesIndividuallyBool;
/// A prefix string to be added to the beginning of each item printed to the log.
/// Default nil.  This can be set to a value such as “KVA: “ to make filtering log messages easier.  When this is used in conjunction with var <code>printLinesIndividuallyBool</code> this prefix will be printed at the beginning of each line.
@property (nonatomic, copy) NSString * _Nullable printPrefixString;
/// Return a copy of the logMessageArray.
/// The copy is made safely with synchronization.
- (NSArray<KVALogMessage *> * _Nullable)logMessageArray_copy SWIFT_WARN_UNUSED_RESULT;
@end


/// A class which defines a log level, with enumerated values.
SWIFT_CLASS_NAMED("KVALogLevel")
@interface KVALogLevel : NSObject
/// A log level which never prints visibly to the log.
/// When LogMessage(s) are not printed visibly to the log, they are still posted as notifications.  This enables all LogMessage(s) to be observed, regardless of their current visibility.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALogLevel * _Nonnull never;)
+ (KVALogLevel * _Nonnull)never SWIFT_WARN_UNUSED_RESULT;
/// A log level for an error.
/// The definition of an error adopted by the SDK is anything which is essentially fatal.  This does not mean that there needs to be a crash, but that something failed unrecoverably.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALogLevel * _Nonnull error;)
+ (KVALogLevel * _Nonnull)error SWIFT_WARN_UNUSED_RESULT;
/// A log level for a warning.
/// A warning is generally anything that behaved unexpectedly and should be brought to the developer’s attention.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALogLevel * _Nonnull warn;)
+ (KVALogLevel * _Nonnull)warn SWIFT_WARN_UNUSED_RESULT;
/// A log level for a piece of general information.
/// General information is anything not rising to the level of a warning but also something that does not require you to be debugging a product to see.  This level should be viewed as to be used sparingly, as it is the default log level.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALogLevel * _Nonnull info;)
+ (KVALogLevel * _Nonnull)info SWIFT_WARN_UNUSED_RESULT;
/// A log level for a piece of debug information.
/// Debug information is something helpful to illuminate what is happening, without going into the minutia.
/// note:
/// We previously used osLogType .debug here, but the result was that for some time log levels higher than info weren’t showing in Xamarin apps- even in the simulator.  We were able to see log messages in the “Console” app, but only for info or below.  From my research there seem to be known Apple bug(s) associated with this.  So, for now we’ve switched the osLogType here to .info.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALogLevel * _Nonnull debug;)
+ (KVALogLevel * _Nonnull)debug SWIFT_WARN_UNUSED_RESULT;
/// A log level for a piece of trace information.
/// Trace information is the minutia of what is happening.  This information would clutter the logs, even when debugging, and so is intended to be used when trying to trace down an obscure problem.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALogLevel * _Nonnull trace;)
+ (KVALogLevel * _Nonnull)trace SWIFT_WARN_UNUSED_RESULT;
/// A log level which always prints visibly to the log.
/// When the logLevel is .always and the visibleMaximumLogLevel resolves to .never, the visibleMaximumLogLevel will win, resulting in no visibility.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVALogLevel * _Nonnull always;)
+ (KVALogLevel * _Nonnull)always SWIFT_WARN_UNUSED_RESULT;
+ (nullable instancetype)kva_from:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// The identifier for the instance.
/// This identifier is used when displaying log messages related to this instance.  Assuming that the property identifier is reasonable, this should be set to the Class.identifier of that property, but it can be something else that would make sense to the host app developer.  If the class has a two or three digit alphanumeric prefix it is recommended that the class prefix be omitted.
/// Examples:  “LogLevel.never”, “LogLevel.error”, “LogLevel.warn”, “LogLevel.info”, “LogLevel.debug”, “LogLevel.trace”, “LogLevel.always”.
@property (nonatomic, readonly, copy) NSString * _Nonnull identifier;
/// The universal identifier.
/// Examples:  “never”, “error”, “warn”, “info”, “debug”, “trace”, “always”.
@property (nonatomic, readonly, copy) NSString * _Nonnull universalIdentifier;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class which defines a log message.
SWIFT_CLASS_NAMED("KVALogMessage")
@interface KVALogMessage : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class which defines a network transaction.
SWIFT_CLASS_NAMED("KVANetTransaction")
@interface KVANetTransaction : NSObject <KVANetworkingSetterProvider>
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// An instance of networking.
/// This exists here is related to the both conformances to KVAExecutable and KVANetworkingSetterProvider.  When this instance is constructed it generally receives a value here.  However, when this instance is constructed and then executed as an executable from within the the networking class, the networking class will also when possible stamp itself here as an indication of where it originated, so that this instance can properly utilizely networking resources.
@property (nonatomic, weak) KVANetworking * _Nullable networking;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A queue of KVANetTransaction(s).
/// This class is a queue of KVANetTransaction(s) which exists for the purpose of holding transactions.  This queue is emptied as those transactions are completed.
SWIFT_CLASS_NAMED("KVANetTransactionQueue")
@interface KVANetTransactionQueue : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A network transaction type.
/// This generally corresponds to Kochava’s “action” key.
SWIFT_CLASS_NAMED("KVANetTransactionType")
@interface KVANetTransactionType : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class KVAPrivacy;

/// The class KVANetworking provides basic networking support.
SWIFT_CLASS_NAMED("KVANetworking")
@interface KVANetworking : NSObject
/// Configure (update) the instance from another object.
/// This method is used to configure the instance.  It can be called from the host to override (or else default) various parameters.  The structure of the object you provide has the same capability as that which the server may return.  Additionally you can wrap the parameters you provide in objects $override$, $override.append$, $default$, or $default.append$, to indicate how these options are treated relative to the server’s options.
/// $override$:  Elements within this object will override any options of the same name specified by the server.
/// $override.append$:  Elements within this object will append/override any previously established $override$.  $override$ does not need to be used first.
/// $default$:  Elements within this object will serve as a default for any options of the same name when not specified by the server.
/// $default.append$:  Elements within this object will append/override any previously established $default$.  $default$ does not need to be used first.
/// \param object An object from which to configure the instance.  This is most commonly a JSON object.
///
/// \param context The context from which the object was provided.  In rare cases this may have some bearing on the proper interpretation of what was provided.
///
- (void)configureWith:(id _Nullable)object context:(KVAContext * _Nullable)context;
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// Execute an advanced instruction.
/// \param universalIdentifier A universal identifier for the advanced instruction.
///
/// \param parameter A parameter object for the advanced instruction.  This parameter is optional depending on the universalIdentifier specified.
///
/// \param prerequisiteTaskIdentifierArray An optional array of task identifiers to use as prerequisites.
///
- (void)executeAdvancedInstructionWithUniversalIdentifier:(NSObject * _Nonnull)universalIdentifier parameter:(id _Nullable)parameter prerequisiteTaskIdentifierArray:(NSArray<NSString *> * _Nullable)prerequisiteTaskIdentifierArray;
/// A feature which is responsible for privacy, including intelligent consent.
/// Privacy profiles are automatically registered from the server.  Alternatively create and register a privacy profile locally by calling class <code>KVAPrivacyProfile</code> func <code>KVAPrivacyProfile/register(name:payloadKeyStringArray:)</code>.  Enable (or explicitly disable) a profile by calling class <code>KVAPrivacy</code> func <code>KVAPrivacy/setEnabledBool(forProfileName:enabledBool:)</code>.
@property (nonatomic, readonly, strong) KVAPrivacy * _Nonnull privacy;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class KVAPrivacyProfile;

SWIFT_PROTOCOL("_TtP11KochavaCore26KVAPrivacyProfileRegistrar_")
@protocol KVAPrivacyProfileRegistrar
- (void)registerProfile:(KVAPrivacyProfile * _Nonnull)profile;
@end


/// A feature which is responsible for privacy, including intelligent consent.
SWIFT_CLASS_NAMED("KVAPrivacy")
@interface KVAPrivacy : NSObject <KVANetworkingSetterProvider, KVAPrivacyProfileRegistrar>
/// Register a profile.
/// \param profile The profile to register.
///
- (void)registerProfile:(KVAPrivacyProfile * _Nonnull)profile;
/// Set a boolean indicating if the specified profile name is enabled.
/// See func <code>register(profile:)</code>.
/// \param profileName The name of a profile.
///
/// \param enabledBool A boolean indicating if enabled.
///
- (void)setEnabledBoolForProfileName:(NSString * _Nonnull)profileName enabledBool:(BOOL)enabledBool;
/// Set a boolean indicating if the specified profile name is enabled.
/// See func <code>setEnabledBool(forProfileName:enabledBool:)</code>
/// See func <code>register(profile:)</code>.
/// \param profileNameString The name of a profile.
///
/// \param enabledBool A boolean indicating if enabled.
///
- (void)setEnabledBoolForProfileNameString:(NSString * _Nonnull)profileNameString enabledBool:(BOOL)enabledBool SWIFT_DEPRECATED_MSG("Modern Objective-C-style method deprecated.  Use Swift func setEnabledBool(forProfileName:enabledBool:) instead.", "setEnabledBoolForProfileName:enabledBool:");
/// A feature which serves as an authority related to consent for the sharing of personal data.
/// Data sharing privacy laws such as GDPR require consent to be obtained before certain kinds of personal data may be collected, kept in memory, persisted or retained in persistent storage, and/or shared with partners.  During the natural lifecycle, there are times where partners may be added and cause the consent status to fall back to an unknown state.  Later the user may again be prompted and the consent status may (or may not) again come to be known.  All of this is predicated upon whether or not consent is required, which is governed by a variety of factors such as location.
@property (nonatomic, readonly, strong) KVAConsent * _Nonnull intelligentConsent;
/// An instance of networking.
@property (nonatomic, weak) KVANetworking * _Nullable networking;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@protocol KVAPrivacyProfileRegistrarProvider;

/// A privacy profile.
SWIFT_CLASS_NAMED("KVAPrivacyProfile")
@interface KVAPrivacyProfile : NSObject <KVANetworkingSetterProvider>
/// Create a privacy profile and then register it.
/// \param name The name of the privacy profile.
///
/// \param payloadKeyStringArray An array of payload keys (datapoint identifiers).
///
+ (void)registerWithName:(NSString * _Nonnull)name payloadKeyStringArray:(NSArray<NSString *> * _Nullable)payloadKeyStringArray;
/// Create a privacy profile and then register it.
/// \param nameString The name of the privacy profile.
///
/// \param payloadKeyStringArray An array of payload keys (datapoint identifiers).
///
+ (void)registerWithNameString:(NSString * _Nonnull)nameString payloadKeyStringArray:(NSArray<NSString *> * _Nullable)payloadKeyStringArray SWIFT_DEPRECATED_MSG("Modern Objective-C-style method deprecated.  Use Swift func register(name:payloadKeyStringArray:) instead.", "registerWithName:payloadKeyStringArray:");
/// Create a privacy profile and then register it.
/// \param name The name of the privacy profile.
///
/// \param payloadKeyStringArray An array of payload keys (datapoint identifiers).
///
/// \param registrarArray An array of KVAPrivacyProfileRegistrarProvider to which to register the privacy profile.
///
+ (void)registerWithName:(NSString * _Nonnull)name payloadKeyStringArray:(NSArray<NSString *> * _Nullable)payloadKeyStringArray registrarArray:(NSArray<id <KVAPrivacyProfileRegistrarProvider>> * _Nullable)registrarArray;
/// Create a privacy profile and then register it.
/// \param nameString The name of the privacy profile.
///
/// \param payloadKeyStringArray An array of payload keys (datapoint identifiers).
///
/// \param registrarArray An array of KVAPrivacyProfileRegistrarProvider to which to register the privacy profile.
///
+ (void)registerWithNameString:(NSString * _Nonnull)nameString payloadKeyStringArray:(NSArray<NSString *> * _Nullable)payloadKeyStringArray registrarArray:(NSArray<id <KVAPrivacyProfileRegistrarProvider>> * _Nullable)registrarArray SWIFT_DEPRECATED_MSG("Modern Objective-C-style method deprecated.  Use Swift func register(name:payloadKeyStringArray:registrarArray:) instead.", "registerWithName:payloadKeyStringArray:registrarArray:");
/// Create a privacy profile and then register it.
/// \param name The name of the privacyProfile.
///
/// \param payloadKeyStringArray An array of datapoint identifiers.
///
/// \param payloadIdStringArray An array of payload identifiers.
///
/// \param registrarArray An array of KVAPrivacyProfileRegistrarProvider to which to register the KVAPrivacyProfile.
///
+ (void)registerWithName:(NSString * _Nonnull)name payloadKeyStringArray:(NSArray<NSString *> * _Nullable)payloadKeyStringArray payloadIdStringArray:(NSArray<NSString *> * _Nullable)payloadIdStringArray registrarArray:(NSArray<id <KVAPrivacyProfileRegistrarProvider>> * _Nullable)registrarArray;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// A unique name for the profile.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// An instance of networking.
/// This exists here related to the conformance to KVAExecutable and then KVANetworkingSetterProvider.  When this instance is constructed and then executed as an executable from within the the networking class, the networking class will also when possible stamp itself here as an indication of where it originated, so that this instance can properly default where it should be sent to be executed.  This can be derived from the networking.mutator.mutableDelegate when cast to whatever it may be expected to be.  Because it’s weak it may disappear at some point, but if it’s there it’s a better default than a shared instance.
@property (nonatomic, weak) KVANetworking * _Nullable networking;
/// An array of payload keys (datapoint identifiers).
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable payloadKeyStringArray;
/// An array of payload identifiers (network transaction types).
@property (nonatomic, readonly, copy) NSArray<NSString *> * _Nullable payloadIdStringArray;
/// A boolean indicating if the sdk should sleep if this profile is active.
@property (nonatomic, readonly) BOOL sleepBool;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



SWIFT_PROTOCOL("_TtP11KochavaCore34KVAPrivacyProfileRegistrarProvider_")
@protocol KVAPrivacyProfileRegistrarProvider
/// A property which conforms to protocol KVAPrivacyProfileRegistrar.
@property (nonatomic, readonly, strong) id <KVAPrivacyProfileRegistrar> _Nonnull privacyProfileRegistrar;
@end



/// A controller for working with products.
SWIFT_CLASS_NAMED("KVAProductController")
@interface KVAProductController : NSObject
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVAProductController * _Nonnull shared;)
+ (KVAProductController * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// Resets product(s).
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
/// \param closure_didComplete A closure which is called upon completion.
///
- (void)products_resetWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool closure_didComplete:(void (^ _Nullable)(void))closure_didComplete;
/// Resets product(s).
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
/// \param includeExternalBool A boolean indicating whether or not external variables should be deleted.  This is intended for testing purposes.  See func <code>products_reset(deleteLocalDataBool:closure_didComplete:)</code> which always supplies this parameter as false.
///
/// \param includeDeviceAppGroupBool A boolean indicating whether or not the deviceAppGroup user defaults should be deleted.  This is where App Clip data is stored.
///
/// \param logMessagePrintBool A boolean indicating if a log messages consistent with this being a call to a public entry point should be printed.
///
/// \param includeHostBool A boolean indicating if you want to include the host.  The host requires an explicit authorization through this boolean.
///
/// \param includeUIBool A boolean indicating if you want to include module KochavaUI.  Module KochavaUI requires an explicit authorization through this boolean.
///
/// \param includeCoreBool A boolean indicating if you want to include module KochavaCore.  Module KochavaCore requires an explicit authorization through this boolean.
///
/// \param moduleNameArray An array of modules to include.  Optional.  If this array is not set then all modules are allowed.  If this is set then only those products whose module names are in this array will be included.  If you set an ‘include’ parameter and also set any value in this array, the name of that ‘include’ parameter must still also be in this array to be included.
///
/// \param closure_didComplete A closure which is called upon completion.
///
- (void)products_resetWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool includeExternalBool:(BOOL)includeExternalBool includeDeviceAppGroupBool:(BOOL)includeDeviceAppGroupBool logMessagePrintBool:(BOOL)logMessagePrintBool includeHostBool:(BOOL)includeHostBool includeUIBool:(BOOL)includeUIBool includeCoreBool:(BOOL)includeCoreBool moduleNameArray:(NSArray<NSString *> * _Nullable)moduleNameArray closure_didComplete:(void (^ _Nullable)(void))closure_didComplete;
/// Shuts down product(s).
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
/// \param closure_didComplete A closure which is called upon completion.
///
- (void)products_shutdownWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool closure_didComplete:(void (^ _Nullable)(void))closure_didComplete;
/// Shuts down product(s).
/// \param deleteLocalDataBool A boolean indicating whether or not local data should be deleted.
///
/// \param includeHostBool A boolean indicating if you want to include the host.  The host requires an explicit authorization through this boolean.
///
/// \param includeUIBool A boolean indicating if you want to include module KochavaUI.  Module KochavaUI requires an explicit authorization through this boolean.
///
/// \param includeCoreBool A boolean indicating if you want to include module KochavaCore.  Module KochavaCore requires an explicit authorization through this boolean.
///
/// \param moduleNameArray An array of modules to include.  Optional.  If this array is not set then all modules are allowed.  If this is set then only those products whose module names are in this array will be included.  If you set an ‘include’ parameter and also set any value in this array, the name of that ‘include’ parameter must still also be in this array to be included.
///
/// \param closure_didComplete A closure which is called upon completion.
///
- (void)products_shutdownWithDeleteLocalDataBool:(BOOL)deleteLocalDataBool includeHostBool:(BOOL)includeHostBool includeUIBool:(BOOL)includeUIBool includeCoreBool:(BOOL)includeCoreBool moduleNameArray:(NSArray<NSString *> * _Nullable)moduleNameArray closure_didComplete:(void (^ _Nullable)(void))closure_didComplete;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class for working with system-level properties.
SWIFT_CLASS_NAMED("KVASystem")
@interface KVASystem : NSObject
/// The singleton shared instance.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVASystem * _Nonnull shared;)
+ (KVASystem * _Nonnull)shared SWIFT_WARN_UNUSED_RESULT;
/// A shared instance, for convenience— optional.
/// See var <code>shared</code>.  This variable will be nil prior to the shared instance being defaulted.  This may be used to optionally invalidate any existing shared instance without causing it to first be defaulted in the process.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) KVASystem * _Nullable shared_optional;)
+ (KVASystem * _Nullable)shared_optional SWIFT_WARN_UNUSED_RESULT;
/// A boolean indicating if the current host is an app clip.
/// This property will return a default value based on whether or not it can be detected that the host is an app clip.  It uses the bundle identifier and looks for the default suffix of “.Clip” (case insensitive).  If it finds that suffix then this value will default to true, otherwise false.  If this assumption is not accurate for the host, this value can be set explicitly.
@property (nonatomic) BOOL appClipBool;
/// A method which can be called to report that the active state should become true.
/// Calling this method is generally redundant when the host is an application, as this change is observed automatically.  But this method can and should be called in app extensions, such as iMessage apps, to notify when the state is reported to have become active.
- (void)stateActiveDidBecome;
/// A method which can be called to report that the active state should become true.
/// Calling this method is generally redundant when the host is an application, as this change is observed automatically.  But this method can and should be called in app extensions, such as iMessage apps, to notify when the state is reported to have become active.
/// \param sourceString A string which describes the source that is originating the state change.
///
- (void)stateActiveDidBecomeWithSourceString:(NSString * _Nonnull)sourceString;
/// A method which can be called to report that the active state should resign true.
/// Calling this method is generally redundant when the host is an application, as this change is observed automatically.  But this method can and should be called in app extensions, such as iMessage apps, to notify when the state is reported to have resigned active.
- (void)stateActiveWillResign;
/// A method which can be called to report that the active state should resign true.
/// Calling this method is generally redundant when the host is an application, as this change is observed automatically.  But this method can and should be called in app extensions, such as iMessage apps, to notify when the state is reported to have resigned active.
/// \param sourceString A string which describes the source that is originating the state change.
///
- (void)stateActiveWillResignWithSourceString:(NSString * _Nonnull)sourceString;
/// A constant to use as the source when reporting that a MessagesAppViewController did become active.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull messagesAppViewControllerDidBecomeActiveSourceString;)
+ (NSString * _Nonnull)messagesAppViewControllerDidBecomeActiveSourceString SWIFT_WARN_UNUSED_RESULT;
/// A constant to use as the source when reporting that a MessagesAppViewController did resign active.
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, copy) NSString * _Nonnull messagesAppViewControllerDidResignActiveSourceString;)
+ (NSString * _Nonnull)messagesAppViewControllerDidResignActiveSourceString SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class for working with a low level system (sys/) functions.
/// This class is a higher-level wrapper for system (sys/) functions, such as sys/utsname.h
SWIFT_CLASS_NAMED("KVASystemLow")
@interface KVASystemLow : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class for tagging things for debugging, especially leaks.
/// Instantiate a tag wherever you think something might be getting retained.  If the tag is retained in instruments, it looks like you’re right.  The various lifeycle events also generate messages which you can see in the log.
SWIFT_CLASS_NAMED("KVATag")
@interface KVATag : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class which defines a high-level task.
SWIFT_CLASS_NAMED("KVATask")
@interface KVATask : NSObject <KVANetworkingSetterProvider>
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
/// An instance of networking.
/// This exists here is related to the both conformances to KVAExecutable and KVANetworkingSetterProvider.  When this instance is constructed it generally receives a value here.  However, when this instance is constructed and then executed as an executable from within the the networking class, the networking class will also when possible stamp itself here as an indication of where it originated, so that this instance can properly utilizely networking resources.
@property (nonatomic, strong) KVANetworking * _Nullable networking;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class which defines a series of time intervals, which express a waterfall pattern.
SWIFT_CLASS_NAMED("KVATimeIntervalSeries")
@interface KVATimeIntervalSeries : NSObject <NSCopying>
- (id _Nonnull)copyWithZone:(struct _NSZone * _Nullable)zone SWIFT_WARN_UNUSED_RESULT;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// A class which wraps a timer with an advanced and high-level interface.
SWIFT_CLASS_NAMED("KVATimer")
@interface KVATimer : NSObject
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A high-level wrapper for a value, along with its associated meta value(s).
SWIFT_CLASS_NAMED("KVAValue")
@interface KVAValue : NSObject
/// Return a description of the instance.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@interface NSArray<ObjectType> (SWIFT_EXTENSION(KochavaCore))
+ (nullable instancetype)kva_from:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Create an instance from another object, allowing for the elementClass to be explictly specified.
/// \param object An object from which to create the instance.  This is expected to be an NSArray.  The elements inside may be native class objects or may be other representations which can be resolved to native class objects.
///
/// \param elementClass The class of the element(s).
///
+ (nullable instancetype)kva_from:(id _Nullable)object elementClass:(Class _Nullable)elementClass initializedObject:(id _Nullable)initializedObject SWIFT_WARN_UNUSED_RESULT;
@end


@interface NSData (SWIFT_EXTENSION(KochavaCore))
+ (nullable instancetype)kva_from:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@end


@interface NSDate (SWIFT_EXTENSION(KochavaCore))
+ (nullable instancetype)kva_from:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@end



@interface NSDictionary<KeyType, ObjectType> (SWIFT_EXTENSION(KochavaCore))
+ (nullable instancetype)kva_from:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@end




@interface NSNumber (SWIFT_EXTENSION(KochavaCore))
+ (nullable instancetype)kva_from:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@end


@interface NSString (SWIFT_EXTENSION(KochavaCore))
/// Return a json string serialized from a json object.
/// \param prettyPrintBool A boolean indicating whether you want the json to be pretty printed.  Pretty printing involves adding carriage returns, indentation, etc.  It generally makes it more human readable but increases the total bytes.
///
///
/// returns:
/// A formatted string.
+ (NSString * _Nullable)kva_stringFromJSONObject:(id _Nullable)jsonObject prettyPrintBool:(BOOL)prettyPrintBool SWIFT_WARN_UNUSED_RESULT;
+ (nullable instancetype)kva_from:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
/// Return a JSON object, assuming that the string represents JSON.
- (id _Nullable)kva_serializedJSONObjectWithPrintErrorsBool:(BOOL)printErrorsBool SWIFT_WARN_UNUSED_RESULT;
@end



@interface UIApplication (SWIFT_EXTENSION(KochavaCore))
/// Return the sharedApplication optionally.
/// This method wraps the sharedApplication method to avoid compiler issues with accessing this property from application extensions.  In such cases it will simply be not returned.
+ (UIApplication * _Nullable)kva_shared SWIFT_WARN_UNUSED_RESULT;
@end


@interface NSUserDefaults (SWIFT_EXTENSION(KochavaCore))
/// Return a properly formatted key name.
/// This will take an identifierString such as “someIdentifierString” and with a storageIdentifier such as “someStorageIdentifier”, turn it into something like the following:  com.kochava.KochavaTracker.someIdentifierString.someStorageIdentifier.  The reason why we are placing the storage id at the end, as opposed to before the identifierString, is because our legacy persisted values never had this key segment.  Inserting one at that location would cause the keys to be sorted inconsistently when compared against a nil value.  By placing it at the end, the order will be consistent, although interlaced.
/// \param prefixString A prefix for the key.  Example: “com.kochava.KochavaTracker”.
///
/// \param identifierString An identifier string.  Example: “ClassName.fieldName”.
///
/// \param storageIdentifier An optional storage identifier string.  Example: “Two”, or nil.
///
+ (NSString * _Nonnull)kva_keyNameStringWithPrefixString:(NSString * _Nullable)prefixString identifierString:(NSString * _Nullable)identifierString storageIdentifier:(NSString * _Nullable)storageIdentifier SWIFT_WARN_UNUSED_RESULT;
@end

#endif
#if defined(__cplusplus)
#endif
#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif

#else
#error unsupported Swift architecture
#endif
